package 哈希表;

public class M2扩容 {
    /**
     * 扩容
     * HashMap每次扩容都是建立一个新的table数组，长度和容量阈值都变为原来的两倍，然后把原数组元素重新映射到新数组上，具体步骤如下：
     *
     * 首先会判断table数组长度，如果大于0说明已被初始化过，那么按当前table数组长度的2倍进行扩容，阈值也变为原来的2倍
     * 若table数组未被初始化过，且threshold(阈值)大于0说明调用了HashMap(initialCapacity, loadFactor)构造方法，那么就把数组大小设为threshold
     * 若table数组未被初始化，且threshold为0说明调用HashMap()构造方法，那么就把数组大小设为16，threshold设为16*0.75
     * 接着需要判断如果不是第一次初始化，那么扩容之后，要重新计算键值对的位置，并把它们移动到合适的位置上去，如果节点是红黑树类型的话则需要进行红黑树的拆分。
     * 这里有一个需要注意的点就是在JDK1.8 HashMap扩容阶段重新映射元素时不需要像1.7版本那样重新去一个个计算元素的hash值，
     * 而是通过hash & oldCap的值来判断，若为0则索引位置不变，不为0则新索引=原索引+旧数组长度，为什么呢？具体原因如下：
     *
     * 链表树化
     * 指的就是把链表转换成红黑树，树化需要满足以下两个条件：
     *
     * 链表长度大于等于8
     * table数组长度大于等于64
     * 为什么table数组容量大于等于64才树化？
     *
     * 因为当table数组容量比较小时，键值对节点 hash 的碰撞率可能会比较高，进而导致链表长度较长。
     * 这个时候应该优先扩容，而不是立马树化。
     */
}
